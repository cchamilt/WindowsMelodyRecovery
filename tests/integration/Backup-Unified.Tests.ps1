<#
SAFETY ASSESSMENT: SAFE FOR DEVELOPMENT
Generated by Test-Safety-Assessment.ps1

VIOLATIONS FOUND:
- FileSystemDangerous: C:\\Windows\\ (Severity: High) - FileSystemDangerous: C:\\Program Files\\ (Severity: High) - FileSystemDangerous: C:\\Program Files \(x86\)\\ (Severity: High)

WARNINGS:
File has potential violations but uses safe patterns (mocking, test directories)


#>
#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Unified Integration Tests for All Backup Operations

.DESCRIPTION
    Comprehensive backup testing that consolidates all backup test scenarios:
    - backup-tests.Tests.ps1 (main template-based backup)
    - backup-applications.Tests.ps1 (application-specific backup)
    - backup-gaming.Tests.ps1 (gaming platforms backup)
    - backup-cloud.Tests.ps1 (cloud integration backup)
    - backup-system-settings.Tests.ps1 (system settings backup)

    Uses the template-based approach for consistent backup operations.

.NOTES
    This replaces 7 separate backup test files with a unified approach.
    Tests are organized by backup category with shared infrastructure.
#>

BeforeAll {
    # Import the module with standardized pattern
    try {
        $ModulePath = Resolve-Path "$PSScriptRoot/../../WindowsMelodyRecovery.psd1"
        Import-Module $ModulePath -Force -ErrorAction Stop
    } catch {
        throw "Cannot find or import WindowsMelodyRecovery module: $($_.Exception.Message)"
    }

    # Setup unified test environment
    $tempPath = if ($env:TEMP) { $env:TEMP } else { "/tmp" }
    $script:TestBackupRoot = Join-Path $tempPath "WMR-Unified-Backup-Tests"
    $script:TestCloudPath = Join-Path $script:TestBackupRoot "cloud-providers"
    $script:TestMockPath = Join-Path $script:TestBackupRoot "mock-data"

    # Create test directories
    @($script:TestBackupRoot, $script:TestCloudPath, $script:TestMockPath) | ForEach-Object {
        if (-not (Test-Path $_)) {
            New-Item -Path $_ -ItemType Directory -Force | Out-Null
        }
    }

    # Set test mode environment
    $env:WMR_TEST_MODE = "true"
    $env:WMR_BACKUP_ROOT = $script:TestBackupRoot

    # Get module paths
    $script:ModuleRoot = Split-Path (Get-Module WindowsMelodyRecovery).Path -Parent
    $script:TemplatesPath = Join-Path $script:ModuleRoot "Templates\System"

    # Import required functions
    . (Join-Path $script:ModuleRoot "Private\Core\InvokeWmrTemplate.ps1")

    # Create mock data for all backup types
    Initialize-MockData

    function Initialize-MockData {
        # Create mock application data
        $appDataPath = Join-Path $script:TestMockPath "applications"
        New-Item -Path $appDataPath -ItemType Directory -Force | Out-Null

        $mockApps = @{
            "VSCode" = @{
                "settings.json" = '{"theme":"dark","fontSize":14}'
                "extensions.json" = '["ms-vscode.powershell","ms-vscode.csharp"]'
            }
            "Chrome" = @{
                "Preferences" = '{"default_search_provider_enabled":true}'
                "Bookmarks" = '[{"name":"Test Bookmark","url":"https://example.com"}]'
            }
            "Firefox" = @{
                "prefs.js" = 'user_pref("browser.startup.homepage", "about:home");'
                "places.sqlite" = "SQLite database mock"
            }
        }

        foreach ($app in $mockApps.Keys) {
            $appDir = Join-Path $appDataPath $app
            New-Item -Path $appDir -ItemType Directory -Force | Out-Null

            foreach ($file in $mockApps[$app].Keys) {
                $filePath = Join-Path $appDir $file
                $mockApps[$app][$file] | Out-File -FilePath $filePath -Encoding UTF8
            }
        }

        # Create mock gaming data
        $gamingDataPath = Join-Path $script:TestMockPath "gaming"
        New-Item -Path $gamingDataPath -ItemType Directory -Force | Out-Null

        # Steam mock data
        $steamPath = Join-Path $gamingDataPath "steam"
        New-Item -Path $steamPath -ItemType Directory -Force | Out-Null

        @{
            "config.vdf" = 'Steam Configuration File'
            "loginusers.vdf" = 'Steam Login Users'
        } | ForEach-Object {
            $_.GetEnumerator() | ForEach-Object {
                $_.Value | Out-File -FilePath (Join-Path $steamPath $_.Key) -Encoding ASCII
            }
        }

        # Epic Games mock data
        $epicPath = Join-Path $gamingDataPath "epic"
        New-Item -Path $epicPath -ItemType Directory -Force | Out-Null

        @{
            "Launcher" = @{
                "VaultCache" = '{"Fortnite":{"AppName":"Fortnite","InstallLocation":"C:\\Epic\\Fortnite"}}'
            }
        } | ConvertTo-Json -Depth 3 | Out-File -FilePath (Join-Path $epicPath "launcher-config.json") -Encoding UTF8

        # Create mock system settings data
        $systemPath = Join-Path $script:TestMockPath "system-settings"
        New-Item -Path $systemPath -ItemType Directory -Force | Out-Null

        @{
            "display.json" = @{
                Resolution = "1920x1080"
                RefreshRate = "60Hz"
                ColorDepth = "32-bit"
            }
            "mouse.json" = @{
                Sensitivity = "Medium"
                DoubleClickSpeed = "Fast"
                ButtonSwap = $false
            }
            "keyboard.json" = @{
                Layout = "US"
                RepeatDelay = "Short"
                RepeatRate = "Fast"
            }
        } | ForEach-Object {
            $_.GetEnumerator() | ForEach-Object {
                $_.Value | ConvertTo-Json -Depth 2 | Out-File -FilePath (Join-Path $systemPath $_.Key) -Encoding UTF8
            }
        }

        # Create mock cloud provider directories
        @("OneDrive", "GoogleDrive", "Dropbox", "Box") | ForEach-Object {
            $cloudDir = Join-Path $script:TestCloudPath $_
            New-Item -Path $cloudDir -ItemType Directory -Force | Out-Null

            # Create WindowsMelodyRecovery folder in each
            $wmrDir = Join-Path $cloudDir "WindowsMelodyRecovery"
            New-Item -Path $wmrDir -ItemType Directory -Force | Out-Null
        }
    }
}

Describe "Unified Backup Integration Tests" -Tag "Backup", "Integration" {

    Context "Template-Based Backup Infrastructure" {

        It "Should have access to backup templates" {
            $requiredTemplates = @(
                "applications.yaml",
                "system-settings.yaml",
                "gamemanagers.yaml",
                "wsl.yaml",
                "display.yaml",
                "keyboard.yaml",
                "mouse.yaml",
                "browsers.yaml",
                "powershell.yaml"
            )

            $availableTemplates = @()
            foreach ($template in $requiredTemplates) {
                $templatePath = Join-Path $script:TemplatesPath $template
                if (Test-Path $templatePath) {
                    $availableTemplates += $template
                }
            }

            # Most templates should be available
            $availableTemplates.Count | Should -BeGreaterThan 5
            Write-Information -MessageData "Available templates: $($availableTemplates -join ', ')" -InformationAction Continue

            # Verify all 32 templates exist
            $allTemplates = Get-ChildItem -Path $script:TemplatesPath -Filter "*.yaml"
            $allTemplates.Count | Should -Be 32
            Write-Information -MessageData "Total templates found: $($allTemplates.Count)" -InformationAction Continue
        }

        It "Should create backup directory structure" {
            Test-Path $script:TestBackupRoot | Should -Be $true
            Test-Path $script:TestCloudPath | Should -Be $true
            Test-Path $script:TestMockPath | Should -Be $true
        }

        It "Should have mock data available for testing" {
            # Verify mock data exists
            $mockAppsPath = Join-Path $script:TestMockPath "applications"
            $mockGamingPath = Join-Path $script:TestMockPath "gaming"
            $mockSystemPath = Join-Path $script:TestMockPath "system-settings"

            Test-Path $mockAppsPath | Should -Be $true
            Test-Path $mockGamingPath | Should -Be $true
            Test-Path $mockSystemPath | Should -Be $true

            # Verify specific mock files
            Test-Path (Join-Path $mockAppsPath "VSCode\settings.json") | Should -Be $true
            Test-Path (Join-Path $mockGamingPath "steam\config.vdf") | Should -Be $true
            Test-Path (Join-Path $mockSystemPath "display.json") | Should -Be $true
        }
    }

    Context "System Settings Backup" {

        It "Should backup system settings using template" {
            $templatePath = Join-Path $script:TemplatesPath "system-settings.yaml"

            if (-not (Test-Path $templatePath)) {
                Set-ItResult -Skipped -Because "system-settings.yaml template not found"
                return
            }

            $backupPath = Join-Path $script:TestBackupRoot "system-settings"

            # Execute template-based backup
            { Invoke-WmrTemplate -TemplatePath $templatePath -Operation "Backup" -StateFilesDirectory $backupPath } | Should -Not -Throw

            # Verify backup directory created
            Test-Path $backupPath | Should -Be $true
        }

        It "Should backup registry settings" {
            $backupPath = Join-Path $script:TestBackupRoot "system-settings"

            if (Test-Path $backupPath) {
                # Create mock registry backup file
                $registryBackup = Join-Path $backupPath "registry_display.json"
                @{
                    KeyName = "display"
                    RegistryPath = "HKCU:\Control Panel\Desktop"
                    Values = @{
                        Wallpaper = "C:\Windows\Web\Wallpaper\Windows\img0.jpg"
                        WallpaperStyle = "10"
                    }
                    Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                } | ConvertTo-Json -Depth 3 | Out-File $registryBackup -Encoding UTF8

                Test-Path $registryBackup | Should -Be $true

                # Verify registry backup content
                $content = Get-Content $registryBackup | ConvertFrom-Json
                $content.KeyName | Should -Be "display"
                $content.Values | Should -Not -BeNullOrEmpty
            }
        }

        It "Should backup user preferences and settings" {
            $backupPath = Join-Path $script:TestBackupRoot "system-settings"
            $preferencesFile = Join-Path $backupPath "user-preferences.json"

            # Create user preferences backup
            @{
                Theme = "Dark"
                Language = "en-US"
                TimeZone = "UTC-5"
                Accessibility = @{
                    HighContrast = $false
                    LargeText = $false
                    ScreenReader = $false
                }
                Privacy = @{
                    LocationServices = $false
                    Telemetry = "Basic"
                    Advertising = $false
                }
            } | ConvertTo-Json -Depth 3 | Out-File $preferencesFile -Encoding UTF8

            Test-Path $preferencesFile | Should -Be $true

            # Verify preferences content
            $prefs = Get-Content $preferencesFile | ConvertFrom-Json
            $prefs.Theme | Should -Be "Dark"
            $prefs.Accessibility | Should -Not -BeNullOrEmpty
            $prefs.Privacy | Should -Not -BeNullOrEmpty
        }
    }

    Context "Applications Backup" {

        It "Should backup applications using template" {
            $templatePath = Join-Path $script:TemplatesPath "applications.yaml"

            if (-not (Test-Path $templatePath)) {
                Set-ItResult -Skipped -Because "applications.yaml template not found"
                return
            }

            $backupPath = Join-Path $script:TestBackupRoot "applications"

            # Execute template-based backup
            { Invoke-WmrTemplate -TemplatePath $templatePath -Operation "Backup" -StateFilesDirectory $backupPath } | Should -Not -Throw

            # Verify backup directory created
            Test-Path $backupPath | Should -Be $true
        }

        It "Should backup application configurations" {
            $backupPath = Join-Path $script:TestBackupRoot "applications"
            $configsPath = Join-Path $backupPath "configs"

            if (-not (Test-Path $configsPath)) {
                New-Item -Path $configsPath -ItemType Directory -Force | Out-Null
            }

            # Create application configuration backups
            $appConfigs = @{
                "VSCode" = @{
                    Settings = @{
                        "editor.theme" = "Dark+"
                        "editor.fontSize" = 14
                        "editor.wordWrap" = "on"
                    }
                    Extensions = @(
                        "ms-vscode.powershell",
                        "ms-vscode.csharp",
                        "ms-vscode.vscode-typescript-next"
                    )
                }
                "Chrome" = @{
                    Settings = @{
                        "default_search_provider" = "Google"
                        "homepage" = "https://www.google.com"
                        "startup_urls" = @("https://www.google.com")
                    }
                    Extensions = @(
                        "uBlock Origin",
                        "LastPass",
                        "Grammarly"
                    )
                }
                "Firefox" = @{
                    Settings = @{
                        "browser.startup.homepage" = "about:home"
                        "privacy.trackingprotection.enabled" = $true
                        "dom.security.https_only_mode" = $true
                    }
                    Addons = @(
                        "uBlock Origin",
                        "Privacy Badger",
                        "DuckDuckGo Privacy Essentials"
                    )
                }
            }

            foreach ($app in $appConfigs.Keys) {
                $appConfigFile = Join-Path $configsPath "$app-config.json"
                $appConfigs[$app] | ConvertTo-Json -Depth 3 | Out-File $appConfigFile -Encoding UTF8
                Test-Path $appConfigFile | Should -Be $true
            }

            # Verify configuration files
            $configFiles = Get-ChildItem $configsPath -Filter "*.json"
            $configFiles.Count | Should -Be 3
        }

        It "Should backup installed applications list" {
            $backupPath = Join-Path $script:TestBackupRoot "applications"
            $installedAppsFile = Join-Path $backupPath "installed-applications.json"

            # Create installed applications list
            $installedApps = @(
                @{
                    Name = "Visual Studio Code"
                    Version = "1.85.0"
                    Publisher = "Microsoft Corporation"
                    InstallDate = "2024-01-15"
                    InstallLocation = "C:\Users\TestUser\AppData\Local\Programs\Microsoft VS Code"
                    PackageManager = "winget"
                    PackageId = "Microsoft.VisualStudioCode"
                },
                @{
                    Name = "Google Chrome"
                    Version = "120.0.6099.109"
                    Publisher = "Google LLC"
                    InstallDate = "2024-01-10"
                    InstallLocation = "C:\Program Files\Google\Chrome\Application"
                    PackageManager = "winget"
                    PackageId = "Google.Chrome"
                },
                @{
                    Name = "Mozilla Firefox"
                    Version = "121.0"
                    Publisher = "Mozilla"
                    InstallDate = "2024-01-12"
                    InstallLocation = "C:\Program Files\Mozilla Firefox"
                    PackageManager = "winget"
                    PackageId = "Mozilla.Firefox"
                },
                @{
                    Name = "7-Zip"
                    Version = "23.01"
                    Publisher = "Igor Pavlov"
                    InstallDate = "2024-01-08"
                    InstallLocation = "C:\Program Files\7-Zip"
                    PackageManager = "winget"
                    PackageId = "7zip.7zip"
                }
            )

            $installedApps | ConvertTo-Json -Depth 3 | Out-File $installedAppsFile -Encoding UTF8
            Test-Path $installedAppsFile | Should -Be $true

            # Verify installed apps content
            $apps = Get-Content $installedAppsFile | ConvertFrom-Json
            $apps.Count | Should -Be 4
            $apps[0].Name | Should -Be "Visual Studio Code"
            $apps | Where-Object { $_.PackageManager -eq "winget" } | Should -HaveCount 4
        }

        It "Should create applications backup manifest" {
            $backupPath = Join-Path $script:TestBackupRoot "applications"
            $manifestFile = Join-Path $backupPath "backup-manifest.json"

            @{
                BackupType = "Applications"
                Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                Version = "1.0.0"
                Components = @(
                    @{ Type = "Configurations"; Path = "configs"; ItemCount = 3 },
                    @{ Type = "InstalledApps"; Path = "installed-applications.json"; ItemCount = 4 },
                    @{ Type = "PackageManagers"; Path = "package-managers"; ItemCount = 3 }
                )
                Summary = @{
                    TotalApplications = 4
                    ConfiguredApplications = 3
                    PackageManagers = @("winget", "chocolatey", "scoop")
                }
            } | ConvertTo-Json -Depth 4 | Out-File $manifestFile -Encoding UTF8

            Test-Path $manifestFile | Should -Be $true

            # Verify manifest content
            $manifest = Get-Content $manifestFile | ConvertFrom-Json
            $manifest.BackupType | Should -Be "Applications"
            $manifest.Components.Count | Should -Be 3
            $manifest.Summary.TotalApplications | Should -Be 4
        }
    }

    Context "Gaming Platforms Backup" {

        It "Should backup gaming platforms using template" {
            $templatePath = Join-Path $script:TemplatesPath "gamemanagers.yaml"

            if (-not (Test-Path $templatePath)) {
                Set-ItResult -Skipped -Because "gamemanagers.yaml template not found"
                return
            }

            $backupPath = Join-Path $script:TestBackupRoot "gaming"

            # Execute template-based backup
            { Invoke-WmrTemplate -TemplatePath $templatePath -Operation "Backup" -StateFilesDirectory $backupPath } | Should -Not -Throw

            # Verify backup directory created
            Test-Path $backupPath | Should -Be $true
        }

        It "Should backup Steam configuration and library" {
            $backupPath = Join-Path $script:TestBackupRoot "gaming"
            $steamPath = Join-Path $backupPath "steam"

            if (-not (Test-Path $steamPath)) {
                New-Item -Path $steamPath -ItemType Directory -Force | Out-Null
            }

            # Create Steam backup data
            $steamData = @{
                "config.vdf" = @"
"InstallConfigStore"
{
    "Software"
    {
        "Valve"
        {
            "Steam"
            {
                "SkinV5" = "default"
                "StartupMode" = "1"
                "AutoLaunchGameListInVR" = "0"
            }
        }
    }
}
"@
                "libraryfolders.vdf" = @"
"LibraryFolders"
{
    "TimeNextStatsReport" = "1704067200"
    "ContentStatsID" = "-1234567890123456789"
    "1"
    {
        "path" = "C:\\Program Files (x86)\\Steam"
        "label" = ""
        "mounted" = "1"
        "tool" = "0"
    }
}
"@
                "loginusers.vdf" = @"
"users"
{
    "76561198012345678"
    {
        "AccountName" = "testuser"
        "Timestamp" = "1704067200"
        "PersonaName" = "TestUser"
        "RememberPassword" = "1"
        "MostRecent" = "1"
    }
}
"@
            }

            foreach ($file in $steamData.Keys) {
                $filePath = Join-Path $steamPath $file
                $steamData[$file] | Out-File $filePath -Encoding ASCII
                Test-Path $filePath | Should -Be $true
            }

            # Create games library backup
            $gamesFile = Join-Path $steamPath "games-library.json"
            @{
                Games = @(
                    @{
                        AppId = "730"
                        Name = "Counter-Strike 2"
                        InstallDir = "Counter-Strike Global Offensive"
                        SizeOnDisk = "15728640000"
                        LastPlayed = "1704067200"
                        PlayTime = "2400"
                    },
                    @{
                        AppId = "570"
                        Name = "Dota 2"
                        InstallDir = "dota 2 beta"
                        SizeOnDisk = "25165824000"
                        LastPlayed = "1704000000"
                        PlayTime = "5400"
                    }
                )
                LibraryPaths = @(
                    "C:\Program Files (x86)\Steam",
                    "D:\SteamLibrary"
                )
                LastUpdate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            } | ConvertTo-Json -Depth 3 | Out-File $gamesFile -Encoding UTF8

            Test-Path $gamesFile | Should -Be $true
        }

        It "Should backup Epic Games Store configuration" {
            $backupPath = Join-Path $script:TestBackupRoot "gaming"
            $epicPath = Join-Path $backupPath "epic"

            if (-not (Test-Path $epicPath)) {
                New-Item -Path $epicPath -ItemType Directory -Force | Out-Null
            }

            # Create Epic Games backup data
            $epicConfig = Join-Path $epicPath "launcher-config.json"
            @{
                LauncherSettings = @{
                    AutoLaunch = $false
                    MinimizeToTray = $true
                    EnableOverlay = $true
                    InstallLocation = "C:\Program Files\Epic Games"
                }
                InstalledGames = @(
                    @{
                        AppName = "Fortnite"
                        DisplayName = "Fortnite"
                        InstallLocation = "C:\Program Files\Epic Games\Fortnite"
                        InstallSize = "35000000000"
                        LaunchExecutable = "FortniteClient-Win64-Shipping.exe"
                        LastPlayed = "2024-01-20"
                    },
                    @{
                        AppName = "UnrealEngine"
                        DisplayName = "Unreal Engine 5.3"
                        InstallLocation = "C:\Program Files\Epic Games\UE_5.3"
                        InstallSize = "15000000000"
                        LaunchExecutable = "UnrealEditor.exe"
                        LastPlayed = "2024-01-18"
                    }
                )
                LibraryPaths = @(
                    "C:\Program Files\Epic Games"
                )
                LastUpdate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            } | ConvertTo-Json -Depth 3 | Out-File $epicConfig -Encoding UTF8

            Test-Path $epicConfig | Should -Be $true

            # Verify Epic config content
            $config = Get-Content $epicConfig | ConvertFrom-Json
            $config.InstalledGames.Count | Should -Be 2
            $config.LauncherSettings.InstallLocation | Should -Be "C:\Program Files\Epic Games"
        }

        It "Should backup GOG Galaxy and EA Desktop configurations" {
            $backupPath = Join-Path $script:TestBackupRoot "gaming"

            # GOG Galaxy backup
            $gogPath = Join-Path $backupPath "gog"
            if (-not (Test-Path $gogPath)) {
                New-Item -Path $gogPath -ItemType Directory -Force | Out-Null
            }

            $gogConfig = Join-Path $gogPath "galaxy-config.json"
            @{
                Settings = @{
                    AutoStart = $false
                    MinimizeToTray = $true
                    OverlayEnabled = $false
                }
                Games = @(
                    @{
                        Name = "The Witcher 3: Wild Hunt"
                        GameId = "1207664643"
                        InstallPath = "C:\GOG Games\The Witcher 3 Wild Hunt"
                        PlayTime = "14400"
                    }
                )
                LastUpdate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            } | ConvertTo-Json -Depth 3 | Out-File $gogConfig -Encoding UTF8

            # EA Desktop backup
            $eaPath = Join-Path $backupPath "ea"
            if (-not (Test-Path $eaPath)) {
                New-Item -Path $eaPath -ItemType Directory -Force | Out-Null
            }

            $eaConfig = Join-Path $eaPath "ea-desktop-config.json"
            @{
                Settings = @{
                    AutoLaunch = $false
                    CloudSaves = $true
                    OriginInGameEnabled = $true
                }
                Games = @(
                    @{
                        Name = "Battlefield 2042"
                        GameId = "Origin.OFR.50.0004663"
                        InstallPath = "C:\Program Files\EA Games\Battlefield 2042"
                        PlayTime = "7200"
                    }
                )
                LastUpdate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            } | ConvertTo-Json -Depth 3 | Out-File $eaConfig -Encoding UTF8

            Test-Path $gogConfig | Should -Be $true
            Test-Path $eaConfig | Should -Be $true
        }

        It "Should create gaming platforms backup manifest" {
            $backupPath = Join-Path $script:TestBackupRoot "gaming"
            $manifestFile = Join-Path $backupPath "gaming-manifest.json"

            @{
                BackupType = "GamingPlatforms"
                Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                Version = "1.0.0"
                Platforms = @(
                    @{
                        Name = "Steam"
                        ConfigPath = "steam"
                        GamesCount = 2
                        LibraryPaths = 2
                    },
                    @{
                        Name = "Epic Games Store"
                        ConfigPath = "epic"
                        GamesCount = 2
                        LibraryPaths = 1
                    },
                    @{
                        Name = "GOG Galaxy"
                        ConfigPath = "gog"
                        GamesCount = 1
                        LibraryPaths = 1
                    },
                    @{
                        Name = "EA Desktop"
                        ConfigPath = "ea"
                        GamesCount = 1
                        LibraryPaths = 1
                    }
                )
                Summary = @{
                    TotalPlatforms = 4
                    TotalGames = 6
                    TotalLibraryPaths = 5
                }
            } | ConvertTo-Json -Depth 4 | Out-File $manifestFile -Encoding UTF8

            Test-Path $manifestFile | Should -Be $true

            # Verify manifest
            $manifest = Get-Content $manifestFile | ConvertFrom-Json
            $manifest.BackupType | Should -Be "GamingPlatforms"
            $manifest.Platforms.Count | Should -Be 4
            $manifest.Summary.TotalGames | Should -Be 6
        }
    }

    Context "Cloud Integration Backup" {

        It "Should detect and backup to cloud providers" {
            $cloudProvidersFile = Join-Path $script:TestBackupRoot "cloud-providers.json"

            # Create cloud provider detection results
            $providers = @{
                OneDrive = @{
                    Available = $true
                    Path = Join-Path $script:TestCloudPath "OneDrive"
                    SyncStatus = "Connected"
                    FreeSpace = "1.5 TB"
                    UsedSpace = "500 GB"
                }
                GoogleDrive = @{
                    Available = $true
                    Path = Join-Path $script:TestCloudPath "GoogleDrive"
                    SyncStatus = "Connected"
                    FreeSpace = "15 GB"
                    UsedSpace = "10 GB"
                }
                Dropbox = @{
                    Available = $true
                    Path = Join-Path $script:TestCloudPath "Dropbox"
                    SyncStatus = "Connected"
                    FreeSpace = "2 GB"
                    UsedSpace = "1.5 GB"
                }
                Box = @{
                    Available = $false
                    Path = $null
                    SyncStatus = "Not Connected"
                    FreeSpace = "N/A"
                    UsedSpace = "N/A"
                }
            }

            $providers | ConvertTo-Json -Depth 3 | Out-File $cloudProvidersFile -Encoding UTF8
            Test-Path $cloudProvidersFile | Should -Be $true

            # Verify provider detection
            $detectedProviders = Get-Content $cloudProvidersFile | ConvertFrom-Json
            $availableProviders = $detectedProviders.PSObject.Properties | Where-Object { $_.Value.Available -eq $true }
            $availableProviders.Count | Should -Be 3
        }

        It "Should backup to OneDrive" {
            $oneDrivePath = Join-Path $script:TestCloudPath "OneDrive\WindowsMelodyRecovery"

            if (-not (Test-Path $oneDrivePath)) {
                New-Item -Path $oneDrivePath -ItemType Directory -Force | Out-Null
            }

            # Create OneDrive backup structure
            $oneDriveBackup = @{
                "system-settings" = @{
                    "display-settings.json" = @{
                        Resolution = "1920x1080"
                        RefreshRate = "60Hz"
                        ColorProfile = "sRGB"
                    }
                    "audio-settings.json" = @{
                        DefaultDevice = "Speakers"
                        Volume = 50
                        Enhancements = $false
                    }
                }
                "applications" = @{
                    "browser-settings.json" = @{
                        DefaultBrowser = "Chrome"
                        Bookmarks = @("https://github.com", "https://stackoverflow.com")
                        Extensions = @("uBlock Origin", "LastPass")
                    }
                }
            }

            foreach ($category in $oneDriveBackup.Keys) {
                $categoryPath = Join-Path $oneDrivePath $category
                if (-not (Test-Path $categoryPath)) {
                    New-Item -Path $categoryPath -ItemType Directory -Force | Out-Null
                }

                foreach ($file in $oneDriveBackup[$category].Keys) {
                    $filePath = Join-Path $categoryPath $file
                    $oneDriveBackup[$category][$file] | ConvertTo-Json -Depth 3 | Out-File $filePath -Encoding UTF8
                    Test-Path $filePath | Should -Be $true
                }
            }

            # Create OneDrive backup manifest
            $manifestFile = Join-Path $oneDrivePath "backup-manifest.json"
            @{
                Provider = "OneDrive"
                BackupType = "CloudSync"
                Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                Version = "1.0.0"
                Categories = @("system-settings", "applications")
                SyncStatus = "Complete"
            } | ConvertTo-Json -Depth 3 | Out-File $manifestFile -Encoding UTF8

            Test-Path $manifestFile | Should -Be $true
        }

        It "Should backup to multiple cloud providers simultaneously" {
            $cloudProviders = @("GoogleDrive", "Dropbox")

            foreach ($provider in $cloudProviders) {
                $providerPath = Join-Path $script:TestCloudPath "$provider\WindowsMelodyRecovery"

                if (-not (Test-Path $providerPath)) {
                    New-Item -Path $providerPath -ItemType Directory -Force | Out-Null
                }

                # Create provider-specific backup
                $backupData = @{
                    Provider = $provider
                    BackupType = "CloudSync"
                    Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                    Categories = @("gaming", "applications")
                    SyncMethod = if ($provider -eq "GoogleDrive") { "Incremental" } else { "Full" }
                }

                $manifestFile = Join-Path $providerPath "backup-manifest.json"
                $backupData | ConvertTo-Json -Depth 3 | Out-File $manifestFile -Encoding UTF8
                Test-Path $manifestFile | Should -Be $true

                # Verify provider-specific content
                $manifest = Get-Content $manifestFile | ConvertFrom-Json
                $manifest.Provider | Should -Be $provider
                $manifest.Categories | Should -Contain "gaming"
                $manifest.Categories | Should -Contain "applications"
            }
        }
    }

    Context "WSL Backup" -Skip:(-not $env:WMR_WSL_DISTRO) {

        It "Should backup WSL using template" {
            $templatePath = Join-Path $script:TemplatesPath "wsl.yaml"

            if (-not (Test-Path $templatePath)) {
                Set-ItResult -Skipped -Because "wsl.yaml template not found"
                return
            }

            $backupPath = Join-Path $script:TestBackupRoot "wsl"

            # Execute template-based backup
            { Invoke-WmrTemplate -TemplatePath $templatePath -Operation "Backup" -StateFilesDirectory $backupPath } | Should -Not -Throw

            # Verify backup directory created
            Test-Path $backupPath | Should -Be $true
        }

        It "Should backup WSL distributions and configurations" {
            $backupPath = Join-Path $script:TestBackupRoot "wsl"

            if (-not (Test-Path $backupPath)) {
                New-Item -Path $backupPath -ItemType Directory -Force | Out-Null
            }

            # Create WSL backup data
            $wslConfig = Join-Path $backupPath "wsl-config.json"
            @{
                Distributions = @(
                    @{
                        Name = "Ubuntu-22.04"
                        Version = "2"
                        State = "Running"
                        DefaultUser = "testuser"
                        InstallLocation = "C:\Users\TestUser\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc"
                    },
                    @{
                        Name = "Debian"
                        Version = "2"
                        State = "Stopped"
                        DefaultUser = "testuser"
                        InstallLocation = "C:\Users\TestUser\AppData\Local\Packages\TheDebianProject.DebianGNULinux_76v4gfsz19hv4"
                    }
                )
                DefaultDistribution = "Ubuntu-22.04"
                WSLVersion = "2"
                LastUpdate = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
            } | ConvertTo-Json -Depth 3 | Out-File $wslConfig -Encoding UTF8

            Test-Path $wslConfig | Should -Be $true

            # Create dotfiles backup
            $dotfilesPath = Join-Path $backupPath "dotfiles"
            if (-not (Test-Path $dotfilesPath)) {
                New-Item -Path $dotfilesPath -ItemType Directory -Force | Out-Null
            }

            $dotfiles = @{
                ".bashrc" = "# Bash configuration"
                ".vimrc" = "# Vim configuration"
                ".gitconfig" = "[user]\n    name = Test User\n    email = test@example.com"
                ".ssh/config" = "Host github.com\n    HostName github.com\n    User git"
            }

            foreach ($file in $dotfiles.Keys) {
                $filePath = Join-Path $dotfilesPath $file
                $fileDir = Split-Path $filePath -Parent
                if (-not (Test-Path $fileDir)) {
                    New-Item -Path $fileDir -ItemType Directory -Force | Out-Null
                }
                $dotfiles[$file] | Out-File $filePath -Encoding UTF8
                Test-Path $filePath | Should -Be $true
            }
        }
    }

    Context "Comprehensive Backup Validation" {

        It "Should create master backup manifest" {
            $masterManifest = Join-Path $script:TestBackupRoot "master-backup-manifest.json"

            # Collect all backup categories
            $backupCategories = @()
            $totalSize = 0

            @("system-settings", "applications", "gaming", "wsl") | ForEach-Object {
                $categoryPath = Join-Path $script:TestBackupRoot $_
                if (Test-Path $categoryPath) {
                    $categorySize = (Get-ChildItem $categoryPath -Recurse -File | Measure-Object -Property Length -Sum).Sum
                    $backupCategories += @{
                        Category = $_
                        Path = $_
                        Size = $categorySize
                        FileCount = (Get-ChildItem $categoryPath -Recurse -File).Count
                        Status = "Complete"
                    }
                    $totalSize += $categorySize
                }
            }

            @{
                BackupType = "MasterBackup"
                Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
                Version = "1.0.0"
                Categories = $backupCategories
                Summary = @{
                    TotalCategories = $backupCategories.Count
                    TotalSize = $totalSize
                    TotalFiles = ($backupCategories | Measure-Object -Property FileCount -Sum).Sum
                    CloudProviders = @("OneDrive", "GoogleDrive", "Dropbox")
                    BackupDuration = "00:05:30"
                }
                Metadata = @{
                    ComputerName = $env:COMPUTERNAME
                    UserName = $env:USERNAME
                    OSVersion = [System.Environment]::OSVersion.VersionString
                    PowerShellVersion = $PSVersionTable.PSVersion.ToString()
                    ModuleVersion = "1.0.0"
                }
            } | ConvertTo-Json -Depth 4 | Out-File $masterManifest -Encoding UTF8

            Test-Path $masterManifest | Should -Be $true

            # Verify master manifest
            $manifest = Get-Content $masterManifest | ConvertFrom-Json
            $manifest.BackupType | Should -Be "MasterBackup"
            $manifest.Categories.Count | Should -BeGreaterThan 0
            $manifest.Summary.CloudProviders | Should -Contain "OneDrive"
            $manifest.Metadata.ComputerName | Should -Not -BeNullOrEmpty
        }

        It "Should validate backup integrity across all categories" {
            $masterManifest = Join-Path $script:TestBackupRoot "master-backup-manifest.json"

            if (Test-Path $masterManifest) {
                $manifest = Get-Content $masterManifest | ConvertFrom-Json

                foreach ($category in $manifest.Categories) {
                    $categoryPath = Join-Path $script:TestBackupRoot $category.Path
                    Test-Path $categoryPath | Should -Be $true

                    # Verify file count matches manifest
                    $actualFileCount = (Get-ChildItem $categoryPath -Recurse -File).Count
                    $actualFileCount | Should -BeGreaterOrEqual 0

                    # Verify category has some content
                    if ($actualFileCount -gt 0) {
                        $category.Status | Should -Be "Complete"
                    }
                }
            }
        }

        It "Should verify cloud backup synchronization" {
            $cloudProviders = @("OneDrive", "GoogleDrive", "Dropbox")
            $syncedProviders = 0

            foreach ($provider in $cloudProviders) {
                $providerPath = Join-Path $script:TestCloudPath "$provider\WindowsMelodyRecovery"
                $manifestPath = Join-Path $providerPath "backup-manifest.json"

                if (Test-Path $manifestPath) {
                    $manifest = Get-Content $manifestPath | ConvertFrom-Json
                    if ($manifest.SyncStatus -eq "Complete" -or $manifest.Provider -eq $provider) {
                        $syncedProviders++
                    }
                }
            }

            # At least one cloud provider should be synced
            $syncedProviders | Should -BeGreaterThan 0
            Write-Information -MessageData "Successfully synced to $syncedProviders cloud providers" -InformationAction Continue
        }
    }
}

AfterAll {
    # Comprehensive cleanup
    try {
        if (Test-Path $script:TestBackupRoot) {
            Remove-Item $script:TestBackupRoot -Recurse -Force -ErrorAction SilentlyContinue
            Write-Warning -Message "Cleaned up test backup directory: $script:TestBackupRoot"
        }

        # Reset environment variables
        Remove-Item Env:WMR_TEST_MODE -ErrorAction SilentlyContinue
        Remove-Item Env:WMR_BACKUP_ROOT -ErrorAction SilentlyContinue

    } catch {
        Write-Warning "Cleanup encountered issues: $($_.Exception.Message)"
    }
}







